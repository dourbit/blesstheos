#!/usr/bin/env bash

COMMAND_FN=dourbit

# TODO: improve to take "false", "off", or 0 into account
# https://unix.stackexchange.com/questions/185670/what-is-a-best-practice-to-represent-a-boolean-value-in-a-shell-script
bool() { return "$((!${#1}))"; }
eager() {
  # git fetch & docker pull only with dourbit update
  return $(bool "${URBIT_EAGER}")
}

custom-image() {
  if [ ! -z ${URBIT_IMAGE+x} ]; then
    echo "Custom URBIT_IMAGE=$URBIT_IMAGE"
  fi
}

docker-image() {
  if [ ! -z ${URBIT_IMAGE+x} ]; then
    echo $URBIT_IMAGE
  else
    echo "asssaf/urbit:latest"
  fi
}

usage() {
  cat <<EOF
Usage: $COMMAND_FN <command> [args]

The following commands can be run, some of which provide their own usage info:

  install   > downloads some scripts, clones git repos, and sets-up the system
  confirm   > establish that dourbit install has been run / all appears well
  version   > report through urbit -R "build info", including other versions
  current   > a starter current, for now simply gets the urbit-v from above
  update    > does git fetch && docker pull as URBIT_EAGER not set by default
  tagged    > all git releases that have been fetched with the filter applied
  recent    > all git releases newer than the current or a given tag version
  latest    > shows the latest tags from urbit repo of non-rc urbit & urbit-os
  foremost  > the tag of the topmost latest release to use for default build
  existing  > checks that an image exists - so just use it rather than build
  images    > shows all the docker images that have been pulled / built here
  build     > initial docker build - takes an urbit tag or uses latest tag
  image     > shows the docker image currently configured and probably used
  image-id  > shows the docker image id of the current urbit or urbit-os image
  dangling  > lists all dangling images & does exit 1 - keep for instant build
  clean-up  > make sure no dangling images remain and thus waste no space
  bin       > check if a command is an executable file and echo the path to it
  cmd       > check if a command exists; echo the path above or its usage help
  run-zod   > runs a fakezod ship called zod to use for development purposes
  hex-seed  > hexdump -n 32 -e '4/4 "%08X"' /dev/random # for network keys gen
  new-ship  > create a ship, usually a planet for which you have a .key
  new-comet > get a new comet, usually takes some non-trivial time to mine
  piers     > a list of urbit assets contained in ~/data/urbit that can be run
  run       > boots a ship or comet - one of your urbit assets
  host      > have it run a docker container in the background (wip)

EOF
}

errcho() { cat <<< "$@" 1>&2; }

repos() {
  echo "${DOTS_HOME}/use/repos"
}

fetch() {
  local tagpref=${1-'urbit-'}
  local refspec="refs/tags/${tagpref}*:refs/tags/${tagpref}*"
  cd $(repos)/urbit
  git fetch --depth=1 origin "$refspec"
}

silent-fetch() {
  if eager; then fetch >/dev/null 2>&1; fi
}

silent-pull() {
  if eager && docker-image | grep -qe ':latest$'; then
    # if an image isn't tagged latest: assume fixed version / need not pull
    # furthermore $URBIT_EAGER must be set in order to pull
    silent docker pull $(docker-image)
  fi
}

tagged() {
  # NOTE: dourbit latest #calls this twice so we can't fetch here
  # excluding .rc tags
  local filter=${2-'\.rc'} # ideally comes from $URBIT_TAGS_FILTER
  # TODO: conditional filter - empty string, or no var set: so it won't filter
  # https://unix.stackexchange.com/questions/38310/conditional-pipeline#38312
  cd $(repos)/urbit
  git tag -l "${1}*" --format='%(creatordate:short)%09%(refname:strip=2)' \
                     --sort=-creatordate | grep -v -e "$filter"
}

latest() {
  tagged "$@" | head -n 1
}

toptag() {
  # given a command that produces tags same as tagged function above or similar
  $@ | head -n 1 \
     | grep -oe '[[:blank:]]\+.*$' \
     | tr   -d   '[:blank:]'
}

dourbit() {
  if [ $# -eq 0 ]; then
    usage; true; return
  else
    local cmd=$1

    if [ $cmd == "install" ]; then
      "$DOTS_HOME/install/urbit"

    elif [ $cmd == "confirm" ]; then
      # TODO: improve with checks based on exported env vars config
      local good=true
      local dirs=( "~/bin/dourbit"
                   $(repos)/urbit
                   $(repos)/urbit-docker
                 )
      for dir in "${dirs[@]}"; do
        dir="${dir/#\~/$HOME}"
        silent ls $dir
        if [ $? -ne 0 ]; then
          good=false
          echo "Not Found: $dir"
        fi
      done
      if $good; then
        echo "All is in order."
      else
        echo "Maybe run this for an easy fix: $COMMAND_FN install"
        exit 1
      fi

    elif [ $cmd == "version" ]; then
      dourbit urbit -R
      specho $(docker --version)
      echo "URBIT_IMAGE=$(docker-image)"

    elif [ $cmd == "current" ]; then
      silent-pull
      #TODO: this should become the actual build tag rather oldest possible tag
      echo "urbit-v$(dourbit urbit -R \
                 | grep -e '^urbit [0-9]' \
                 | grep -oe '[0-9]\+.*$' \
                 | tr   -d  '[:space:]')"

    elif [ $cmd == "update" ]; then
      specho "Docker :latest ..."
      docker pull $(docker-image)
      specho "Urbit releases ..."
      fetch
      echo

    elif [ $cmd == "tagged" ]; then
      shift
      silent-fetch
      tagged "$@"

    elif [ $cmd == "recent" ]; then
      silent-fetch
      local tag=${2-$(dourbit current)}
      tagged 'urbit-' | sed -e "/${tag}/q"

    elif [ $cmd == "latest" ]; then
      silent-fetch
      echo -e "$(latest 'urbit-v')\n$(latest 'urbit-os-v')" | sort -r

    elif [ $cmd == "foremost" ]; then
      shift
      silent-fetch
      toptag tagged ${1-'urbit-'} ${@:2}

    elif [ $cmd == "existing" ]; then
      local wut=${2-$(docker-image)}
      if [[ ! -z $(docker images -q $wut) ]]; then
        echo $wut
      else
        echo "Not found: $wut"
        if [[ ! -z $(dourbit tagged $wut) ]]; then
          echo "Can build with: dourbit build $wut"
        fi
        exit 1
      fi

    elif [ $cmd == "images" ]; then
      docker images --format "{{.ID}}: {{.Repository}}:{{.Tag}}" \
      | grep 'urbit-v\|urbit-os-v' \
      | sed -e 's/:latest$//g'

    elif [ $cmd == "build" ]; then
      shift
      local tag=$(URBIT_EAGER=true dourbit foremost $@)
      if [ "$tag" == "" ]; then
        echo "Not Found: ${1-'urbit-'}*"
        exit 1
      fi
      cd $(repos)/urbit-docker && \
        git pull && \
        docker build -t $tag --build-arg branch=$tag .

    elif [ $cmd == "image" ]; then
      docker-image

    elif [ $cmd == "image-id" ]; then
      docker images -q $(docker-image) | head -n 1 # there is only 1

    elif [ $cmd == "dangling" ]; then
      # NOTE: there is nothing *urbit* about these images, only dangling ...
      if [ $(docker images --filter 'dangling=true' -q | wc -w) -ne 0 ]; then
        echo "Found dangling / <none> images:"
        docker images --filter "dangling=true" -q
        exit 1
      else
        echo "Nothing is dangling."
        exit 0
      fi

    elif [ $cmd == "clean-up" ]; then
      silent $(dourbit dangling)
      if [ $? -eq 1 ]; then
        echo "docker rmi"
        docker rmi $(docker images --filter "dangling=true" -q --no-trunc)
      else
        echo "Nothing to clean-up."
      fi

    elif [[ $cmd == "bin" || $cmd == "cmd" ]]; then
      # these are similar and related with a bit of code in common
      local name=$2
      if [ $# -eq 1 ]; then
        errcho "Usage: $COMMAND_FN $cmd <command>"
        false; return
      fi

      if [ $cmd == "bin" ]; then
        if check-x ~/bin/dourbit/$name; then
          echo ~/bin/dourbit/$name
        elif check-x "$DOTS_HOME"/bin/dourbit/$name; then
          echo "$DOTS_HOME"/bin/dourbit/$name
        else
          errcho "Not Found: $name"
          false; return
        fi
      fi

      if [ $cmd == "cmd" ]; then
        local found=false
        # is it a script?
        if silent dourbit bin $name; then
          dourbit bin $name
          found=true
        fi
        # is it documented?
        local pattern="^[[:blank:]]\+$name[[:blank:]]\+> "
        usage | grep -q -e "$pattern"
        if [ $? -eq 0 ]; then
          echo $(usage | grep -e "$pattern")
          found=true
        fi
        # unknown command
        if ! $found; then
          usage
          errcho "Not Found: dourbit $name"
          false; return
        fi
      fi

    elif [ $cmd == "hex-seed" ]; then
      hexdump -n 32 -e '4/4 "%08X"' /dev/random
      echo

    elif [ $cmd == "piers" ]; then
      ls "$HOME"/data/urbit | cat

    elif dourbit bin $cmd; then
      # that's a file to be executed with the rest of the given args
      cd "$HOME"/data/urbit
      echo
      custom-image
      if [[ "$cmd" =~ ^run ]] && [[ "$2" =~ ^~ ]]; then
        $(dourbit bin $cmd) ${2:1} ${@:3} # remove the leading ~
      else
        $(dourbit bin $cmd) ${@:2}
      fi
    else
      false; return
    fi
  fi
}

[ $(basename $0) != $COMMAND_FN ] && export -f $COMMAND_FN || $COMMAND_FN "$@"
