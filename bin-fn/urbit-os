#!/usr/bin/env bash

COMMAND_FN=urbit-os

custom-image() {
  if [ ! -z ${URBIT_IMAGE+x} ]; then
    echo "Custom URBIT_IMAGE=$URBIT_IMAGE"
  fi
}

docker-image() {
  if [ ! -z ${URBIT_IMAGE+x} ]; then
    echo $URBIT_IMAGE
  else
    echo "asssaf/urbit:latest"
  fi
}

usage() {
  cat <<EOF
Usage: $COMMAND_FN <command> [args]

The following commands can be run, some of which provide their own usage info:

  install   > downloads some scripts, clones git repos, and sets-up the system
  run-zod   > runs a fakezod ship called zod to use for development purposes
  version   > report through urbit -R "build info", including other versions
  latest    > shows the latest tags from urbit repo of non-rc urbit & urbit-os
  image     > shows the docker image currently in use, follow by: tag or id...
  bin       > check if a command is an executable file and echo the path to it
  cmd       > check if a command exists; echo the path or its usage line
  piers     > a list of urbit assets contained in ~/data/urbit that can be run
  hex-seed  > hexdump -n 32 -e '4/4 "%08X"' /dev/random # for network keys gen
  new-ship  > create a ship, usually a planet for which you have a .key
  new-comet > get a new comet, usually takes some non-trivial time to mine
  run       > boots a ship or comet - one of your urbit assets
  host      > have it run a docker container in the background (wip)

EOF
}

errcho() { cat <<< "$@" 1>&2; }

latest() {
  # excluding .rc tags
  local filter=${2-'\.rc'} # ideally comes from $URBIT_TAGS_FILTER
  # TODO: conditional filter - empty string, or no var set: so it won't filter
  # https://unix.stackexchange.com/questions/38310/conditional-pipeline#38312
  git tag -l "$1*" --format='%(creatordate:short)%09%(refname:strip=2)' \
                   --sort=-creatordate | grep -v -e "$filter" | head -n 1
}

urbit-os() {
  if [ $# -eq 0 ]; then
    usage; true; return
  else
    local cmd=$1

    if [ $cmd == "install" ]; then
      "$DOTS_HOME/install/urbit"

    elif [ $cmd == "version" ]; then
      urbit-os urbit -R
      specho $(docker --version)
      echo "URBIT_IMAGE=$(docker-image)"

    elif [ $cmd == "latest" ]; then
      cd "${DOTS_HOME}/use/repos/urbit"
      silent git fetch --depth=1 origin 'refs/tags/urbit-*:refs/tags/urbit-*'
      echo -e "$(latest 'urbit-v')\n$(latest 'urbit-os-v')" | sort -r

    elif [ $cmd == "image" ]; then
      docker-image

    elif [[ $cmd == "bin" || $cmd == "cmd" ]]; then
      # these are similar and related with a bit of code in common
      local name=$2
      if [ $# -eq 1 ]; then
        errcho "Usage: $COMMAND_FN $cmd <command>"
        false; return
      fi

      if [ $cmd == "bin" ]; then
        if check-x ~/bin/urbit-os/$name; then
          echo ~/bin/urbit-os/$name
        elif check-x "$DOTS_HOME"/bin/urbit-os/$name; then
          echo "$DOTS_HOME"/bin/urbit-os/$name
        else
          errcho "Not Found: $name"
          false; return
        fi
      fi

      if [ $cmd == "cmd" ]; then
        local found=false
        # is it a script?
        if silent urbit-os bin $name; then
          urbit-os bin $name
          found=true
        fi
        # is it documented?
        local pattern="^[[:blank:]]\+$name[[:blank:]]\+> "
        usage | grep -q -e "$pattern"
        if [ $? -eq 0 ]; then
          echo $(usage | grep -e "$pattern")
          found=true
        fi
        # unknown command
        if ! $found; then
          usage
          errcho "Not Found: urbit-os $name"
          false; return
        fi
      fi

    elif [ $cmd == "hex-seed" ]; then
      hexdump -n 32 -e '4/4 "%08X"' /dev/random
      echo

    elif [ $cmd == "piers" ]; then
      ls "$HOME"/data/urbit | cat

    elif urbit-os bin $cmd; then
      # that's a file to be executed with the rest of the given args
      cd "$HOME"/data/urbit
      echo
      custom-image
      if [[ "$cmd" =~ ^run ]] && [[ "$2" =~ ^~ ]]; then
        $(urbit-os bin $cmd) ${2:1} ${@:3} # remove the leading ~
      else
        $(urbit-os bin $cmd) ${@:2}
      fi
    else
      false; return
    fi
  fi
}

[ $(basename $0) != $COMMAND_FN ] && export -f $COMMAND_FN || $COMMAND_FN "$@"
