#!/usr/bin/env bash

COMMAND_FN=holy

usage() {
  cat <<EOF
Usage: $COMMAND_FN <command> [args]

  init      > initializes holy for [bash] or another init/ <shell> use
  path      > provides the path to HOLY_HOME and relative paths or repos
  in        > an alias to holy install - see next
  install   > runs the install script of an <ability> and turns it on
  ability   > checks an <ability> exists though also reports on all of them
  confirm   > some abilities have on/confirm scripts, to verify all is well
  bless     > vouches for a given <ability> installed by other means
  on        > says if an <ability> has been installed + it can holy on [holy]
  up        > does update and upgrade, see the commands below
  update    > does a git pull for \${HOLY_HOME}
  outdated  > same as ${HOLY_HOME}/bin/outdated
  upgrade   > same as ${HOLY_HOME}/bin/upgrade

EOF
}

holy() {
  if [ $# -eq 0 ]; then
    usage; true; return
  else
    local cmd=$1
    shift

    # check whether holy is on
    local holy_on #declaration
    holy_on=$(holy-on) #assignment must be separate to capture $? (bash bug)
    local status=$?
    if [ $status -eq 0 ]; then
      # source any helper functions
      . "$HOLY_HOME"/bin-fn/holy.sh
    elif [ $cmd != "init"]; then
      # bad status and no exception command will not proceed
      errcho $holy_on
      exit 1
    fi

    # Command code-blocks:

    if [ $cmd == "init" ]; then
      local shell=${1-'bash'}
      if [ $status -eq 0 ]; then
        echo "$holy_on"
        echo "Already initialized."
        echo "The following init/ scripts can be run directly, use with caution:"
        find "$HOLY_HOME/init/" -type f -executable -print
      else
        # TODO: check if the init script exists and handle for prettier error?
        # also cover for when the init has been run but the ".*rc" not sourced
        # will need to grep the contents of the files to detect initialization
        ~/.holy/init/$shell
      fi

    elif  [ $cmd == "path" ]; then
      if [ $# -eq 0 ]; then
        echo "$HOLY_HOME"
      elif [ $1 == "repos" ]; then
        echo "$HOLY_HOME"/use/repos
      elif [ -e "$HOLY_HOME/$1" ]; then
        echo "$HOLY_HOME/$1"
      else
        errcho "Not Found: $HOLY_HOME/$1"
        false; return
      fi

    elif [[ $cmd == "in" || $cmd == "install" ]]; then
      local able=$1
      local path="${HOLY_HOME}/install/${able}"
      local onit="$HOLY_HOME/on/ability/$able"
      if [ $# -eq 0 ]; then
        echo "Usage: $COMMAND_FN $cmd <ability>"
        echo
        installable
        echo
      elif installable $able; then
        env-true $HOLY_EAGER &&\
          silent holy update
        $path
        if [ $? -eq 0 ]; then
          cd "$HOLY_HOME"
          mkdir -p $(echo "$onit" | rev | cut -d'/' -f2- | rev)
          echo $(git show --format="%h" --no-patch) > $onit
        else
          errcho "Failed: $COMMAND_FN $cmd $@"
          false; return
        fi
      else
        errcho "Not found: $path"
        false; return
      fi

    elif [ $cmd == "ability" ]; then
      installable $1
      local status=$?
      [[ $# -ne 0 && $status -eq 0 ]] && echo $1
      exit $status

    elif [ $cmd == "confirm" ]; then
      local able=$1
      if [ $# -eq 0 ]; then
        errcho "Usage: $COMMAND_FN $cmd <ability>"
        false; return
      elif [ ! -f "${HOLY_HOME}/on/confirm/$able" ]; then
        # TODO: check if such ability exists
        echo "No confirmation script; assume good: $able"
        true; return #lack of confirm script means auto-confirm
      else
        ${HOLY_HOME}/on/confirm/$able; return
      fi

    elif [ $cmd == "bless" ]; then
      local able=$1
      local onit="$HOLY_HOME/on/ability/$able"
      if [ $# -eq 0 ]; then
        echo "Usage: $COMMAND_FN $cmd <ability>"
        false; return
      elif installable $able; then
        if holy confirm $able; then
          echo "Blessed be this ability."
          mkdir -p $(echo "$onit" | rev | cut -d'/' -f2- | rev)
          echo 'custom' > "$onit"
          true; return
        else
          errcho "Failed: $COMMAND_FN $cmd $@"
          errcho "Ability has failed to confirm."
          false; return
        fi
      else
        errcho "Ability not found for: $able"
        false; return
      fi

    elif [ $cmd == "on" ]; then
      local able=$1
      local onit="${HOLY_HOME}/on/ability/$able"
      if [[ $# -eq 0 || $able == "holy" ]]; then
        echo $holy_on # only the true branch can get this far
      else
        # TODO: allow to check by filename - e.g. node or platforms/node same
        # perhaps create an enabled() function similar to installable()
        if [ -f $onit ]; then
          if holy confirm $able; then
            local stamp=$(stat -c %y "$onit")
            if [ "$(cat $onit)" == "custom" ]; then
              echo "Blessed on $stamp"
            else
              echo "Installed on $stamp"
            fi
            true; return
          else
            errcho "This ability can no longer be confirmed."
            # TODO: refactor the code above into a function
            # to report the details of installed or blessed
            errcho "Perhaps fix with: holy install $able"
            false; return
          fi
        elif installable $able; then
          errcho "Turn on by: holy install $able"
          errcho "Optionally: holy bless $able"
          false; return
        else
          errcho "Ability '$able' not on, nor is it install-able."
          false; return
        fi
      fi

    elif [ $cmd == "up" ]; then
      sudoUse
      env-true $HOLY_EAGER \
      && echo && holy update
      holy upgrade

    elif [ $cmd == "update" ]; then
      echo "Getting the latest blesstheos..."
      cd "$HOLY_HOME" && git pull

    elif [ $cmd == "outdated" ]; then
      if env-true "$HOLY_EAGER"; then
        echo && holy update
      fi
      $(holy path bin/outdated)

    elif [ $cmd == "upgrade" ]; then
      $(holy path bin/upgrade)

    else
      errcho "Not found: holy $cmd"
      false; return
    fi
  fi
}

[ $(basename $0) != $COMMAND_FN ] && export -f $COMMAND_FN || $COMMAND_FN "$@"
