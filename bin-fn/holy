#!/usr/bin/env bash

COMMAND_FN=holy

usage() {
  cat <<EOF
Usage: $COMMAND_FN [ one || you ] <command> [<args>]

  init      > initializes holy for [bash] or another init/ <shell> use
  path      > provides the path to HOLY_HOME and relative paths or repos
  in        > an alias to holy install - see next
  install   > runs the install script of an <ability> and turns it on
  ability   > checks an <ability> exists though also reports on all of them
  confirm   > some abilities have on/confirm scripts, to verify all is well
  bless     > vouches for a given <ability> installed by other means
  on        > says if an <ability> has been installed + it can holy on [holy]
  up        > does update and upgrade, see the commands below
  update    > does a git pull for \${HOLY_HOME}
  outdated  > same as ${HOLY_HOME}/bin/outdated
  upgrade   > same as ${HOLY_HOME}/bin/upgrade

EOF
}

# validates a lead modifier
lead() {
  [[ "$1" == "one" || "$1" == "you" ]] && true || false
}

holy() {
  # NOTE: $HOLY_LEAD makes it possible to change the holy default to "you"
  # which only makes sense if yours is used far more often than "holy one"
  local the=$(lead $HOLY_LEAD && echo $HOLY_LEAD || echo "one")
  if lead $1; then
    the=$1
    shift
  fi
  # command is required
  if [ $# -eq 0 ]; then
    echo
    echo "Missing <command> from usage options below..."
    echo; usage
    true; return
  else
    # the command
    local cmd=$1
    shift

    # check whether holy is on - nothing will be done without it...
    local holy_on
    # assignment must be separate to capture $? (bash bug)
    holy_on=$(holy-on)
    local status=$?
    if [ $status -eq 0 ]; then
      # source any helper functions
      . "$HOLY_HOME"/bin-fn/holy.sh
    # exception to the holy-on rule is `holy one init`
    elif ! [[ $the == "one" && $cmd == "init" ]]; then
      # bad status and no exception command will not proceed
      echo $holy_on
      exit 1
    fi

    # Command code-blocks:

    if [ $cmd == "init" ]; then
      local where=${HOLY_HOME}/init
      # check if holy-on gave an error - $HOLY_HOME unknown
      if [ $status -ne 0 ]; then
        if [ $the == "one" ]; then
          # guess where $HOLY_HOME is (depending on the holy)
          if [ $(basename $(dirname $0)) == "bin-fn" ]; then
            # probably this as it's the actual holy script
            where=$(dirname $0)/../init
          else
            # it's the holy symlink
            where=$(dirname $0)/init
          fi
        else # $the "you" / any other than "one" will require holy-on
          echo $holy_on
          false; return
        fi
      # you a special case because can be anywhere
      elif [ $the == "you" ]; then
        # NOTE: here holy and all helpers are available to use
        # TODO: make the path optional if $DOTS_HOME is already set -
        # can we use holy-on DOTS_HOME for this?
        if [ $# -eq 0 ]; then
          errcho "Please give a path to your dots."
          false; return
        else
          # turn it into an absolute path
          where=$(a-path ${1}/init)
          # if that fails then use the original
          [ "$where" == "" ] && where=${1}/init
          shift
        fi
      fi
      # check if init dir exists at $where / or something is wrong
      # probably $the you path from above as the one should always be found
      if ! [ -d $where ]; then
        echo "Not Found: $where"
        false; return
      fi
      # now what do we run?
      if [ $# -eq 0 ]; then
        echo "No script was asked for."
        echo "Trying init for the current $SHELL shell."
      fi
      local shell=${1-$(basename $SHELL)}
      # there are scripts here that aren't shell init
      # which can also be run (though not advertised)
      local found=$where/$shell
      if [ -x $found ]; then
        # run the script
        $found "$@"
      else
        echo "Not found: $shell"
        echo -n "Can try it with: "
        # only the executables minus some files excluded via the grep below
        find "$where" -type f -executable -exec basename {} \; \
        | grep -Ev 'once|home' \
        | tr '\n' ' '
        echo
        false; return
      fi

    elif  [ $cmd == "path" ]; then
      if [ $# -eq 0 ]; then
        echo "$HOLY_HOME"
      elif [ $1 == "repos" ]; then
        echo "$HOLY_HOME"/use/repos
      elif [ -e "$HOLY_HOME/$1" ]; then
        echo "$HOLY_HOME/$1"
      else
        errcho "Not Found: $HOLY_HOME/$1"
        false; return
      fi

    elif [[ $cmd == "in" || $cmd == "install" ]]; then
      local able=$1
      local path="${HOLY_HOME}/install/${able}"
      local onit="$HOLY_HOME/on/ability/$able"
      if [ $# -eq 0 ]; then
        echo "Usage: $COMMAND_FN $cmd <ability>"
        echo
        installable
        echo
      elif installable $able; then
        env-true $HOLY_EAGER &&\
          silent holy update
        $path
        if [ $? -eq 0 ]; then
          cd "$HOLY_HOME"
          mkdir -p $(echo "$onit" | rev | cut -d'/' -f2- | rev)
          echo $(git show --format="%h" --no-patch) > $onit
        else
          errcho "Failed: $COMMAND_FN $cmd $@"
          false; return
        fi
      else
        errcho "Not found: $path"
        false; return
      fi

    elif [ $cmd == "ability" ]; then
      installable $1
      local status=$?
      [[ $# -ne 0 && $status -eq 0 ]] && echo $1
      exit $status

    elif [ $cmd == "confirm" ]; then
      local able=$1
      if [ $# -eq 0 ]; then
        errcho "Usage: $COMMAND_FN $cmd <ability>"
        false; return
      elif [ ! -f "${HOLY_HOME}/on/confirm/$able" ]; then
        # TODO: check if such ability exists
        echo "No confirmation script; assume good: $able"
        true; return #lack of confirm script means auto-confirm
      else
        ${HOLY_HOME}/on/confirm/$able; return
      fi

    elif [ $cmd == "bless" ]; then
      local able=$1
      local onit="$HOLY_HOME/on/ability/$able"
      if [ $# -eq 0 ]; then
        echo "Usage: $COMMAND_FN $cmd <ability>"
        false; return
      elif installable $able; then
        if holy confirm $able; then
          echo "Blessed be this ability."
          mkdir -p $(echo "$onit" | rev | cut -d'/' -f2- | rev)
          echo 'custom' > "$onit"
          true; return
        else
          errcho "Failed: $COMMAND_FN $cmd $@"
          errcho "Ability has failed to confirm."
          false; return
        fi
      else
        errcho "Ability not found for: $able"
        false; return
      fi

    elif [ $cmd == "on" ]; then
      local able=$1
      local onit="${HOLY_HOME}/on/ability/$able"
      if [[ $# -eq 0 || $able == "holy" ]]; then
        echo $holy_on # only the true branch can get this far
      else
        # TODO: allow to check by filename - e.g. node or platforms/node same
        # perhaps create an enabled() function similar to installable()
        if [ -f $onit ]; then
          if holy confirm $able; then
            local stamp=$(stat -c %y "$onit")
            if [ "$(cat $onit)" == "custom" ]; then
              echo "Blessed on $stamp"
            else
              echo "Installed on $stamp"
            fi
            true; return
          else
            errcho "This ability can no longer be confirmed."
            # TODO: refactor the code above into a function
            # to report the details of installed or blessed
            errcho "Perhaps fix with: holy install $able"
            false; return
          fi
        elif installable $able; then
          errcho "Turn on by: holy install $able"
          errcho "Optionally: holy bless $able"
          false; return
        else
          errcho "Ability '$able' not on, nor is it install-able."
          false; return
        fi
      fi

    elif [ $cmd == "up" ]; then
      sudoUse
      env-true $HOLY_EAGER \
      && echo && holy update
      holy upgrade

    elif [ $cmd == "update" ]; then
      echo "Getting the latest blesstheos..."
      cd "$HOLY_HOME" && git pull

    elif [ $cmd == "outdated" ]; then
      if env-true "$HOLY_EAGER"; then
        echo && holy update
      fi
      $(holy path bin/outdated)

    elif [ $cmd == "upgrade" ]; then
      $(holy path bin/upgrade)

    else
      errcho "Not found: holy $cmd"
      false; return
    fi
  fi
}

[ $(basename $0) != $COMMAND_FN ] && export -f $COMMAND_FN || $COMMAND_FN "$@"
