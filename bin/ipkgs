#!/usr/bin/env bash

# Installs packages, given file[path](s)

# verify it's bash version >= 4
# for associative arrays, used next
if [ ${BASH_VERSION%%[^0-9]*} -lt 4 ]; then
  echo "Bash must be version 4 or greater."
  echo "Currently it's: '${BASH_VERSION}'."
  exit 1
fi

declare where # path prefix
if [ "$1" == "-p" ]; then
  # announce to provide your own valid package path(s) with -p
  where=''
  shift
elif [ "$#" -ne 0 ]; then
  # less typing - uses env var or the relative default
  echo Using \$IPKGS_PATH = \'${IPKGS_PATH:=$(realpath "$(dirname $0)/../install/packages")}\'.
  where="$IPKGS_PATH/"
fi

if [ "$#" -eq 0 ]; then
    echo "Usage: $(basename $0) [-p] file(s)"
    exit 1
fi

# special cases when command isn't the filename
# if a file isn't in this list, the $command is taken up until the first dash
declare -A special=(
  ["apt"]="apt-get"
  ["apt-get"]="apt-get" # just for example, or the '-get' would get truncated
  ["brew-cask"]="brew cask"
)

# TODO: verify $pm is installed, as well as...
# system-specific, if comand or filename match any of the following
declare -A syscheck=(
  ["apm-darwin"]="darwin"
  ["apt-get"]="linux" # could check for ubuntu or debian
  ["brew"]="darwin"
  ["brew cask"]="darwin"
)

# it's `$pm install $package` - except for the following special cases
declare -A install=(
  ["npm"]="npm i -g"
)

# do glob expansion with correct paths
items=()
shopt -s nullglob
for item in "$@"; do
  path=${where}${item}
  items+=($path)
done
# echo "${#items[@]}"

for path in "${items[@]}"; do
  id=$(basename "$path")
  # it seems like * glob-expands in a sed regexp a set -f prevents that
  pm=$(set -f && echo $id | sed s/-.*//) # package manager default
  [[ ${special[$id]+_} ]] && pm=${special[$id]}

  command="$pm install"
  [[ ${install[$pm]+_} ]] && command=${install[$pm]}

  echo
  echo "Installing '$(basename $path)' packages with \`$command\`..."

  sed -f $(dirname "$0")/keys.sed $path | xargs -n 1 echo \$ $command
done
